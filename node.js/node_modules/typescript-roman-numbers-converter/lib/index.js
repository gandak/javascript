"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toRomanLargeStr = exports.toRomanLarge = exports.isRoman = exports.toArabic = exports.toRoman = exports.BaseNumbers = void 0;
var RomanNumber_1 = require("./RomanNumber");
exports.BaseNumbers = [
    new RomanNumber_1.RomanNumber(1000, 'M'),
    new RomanNumber_1.RomanNumber(900, 'CM'),
    new RomanNumber_1.RomanNumber(500, 'D'),
    new RomanNumber_1.RomanNumber(400, 'CD'),
    new RomanNumber_1.RomanNumber(100, 'C'),
    new RomanNumber_1.RomanNumber(90, 'XC'),
    new RomanNumber_1.RomanNumber(50, 'L'),
    new RomanNumber_1.RomanNumber(40, 'XL'),
    new RomanNumber_1.RomanNumber(10, 'X'),
    new RomanNumber_1.RomanNumber(9, 'IX'),
    new RomanNumber_1.RomanNumber(5, 'V'),
    new RomanNumber_1.RomanNumber(4, 'IV'),
    new RomanNumber_1.RomanNumber(1, 'I'),
];
function toRoman(x) {
    var i;
    var romanNumber;
    if (x <= 0 || x > 3999) {
        return '';
    }
    else {
        i = 0;
        var toReturn = '';
        x = Math.floor(x);
        while (x > 0) {
            romanNumber = exports.BaseNumbers[i];
            if (Math.floor(x / romanNumber.num) === 0) {
                ++i;
            }
            else {
                toReturn = toReturn + romanNumber.str;
                x -= romanNumber.num;
            }
        }
        return toReturn;
    }
}
exports.toRoman = toRoman;
function toArabic(x) {
    var romanNumeral = x.toUpperCase();
    if (!isRoman(romanNumeral)) {
        return null;
    }
    var result = 0;
    var i = 0;
    while (romanNumeral.length > 0 && i < exports.BaseNumbers.length) {
        var romanNumber = exports.BaseNumbers[i];
        if (romanNumeral.startsWith(romanNumber.str)) {
            result += romanNumber.num;
            romanNumeral = romanNumeral.substring(romanNumber.str.length);
        }
        else {
            i++;
        }
    }
    if (romanNumeral.length > 0) {
        return null;
    }
    return result;
}
exports.toArabic = toArabic;
function isRoman(x) {
    var regex = new RegExp('^M{0,4}(CM|CD|D?C{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})$');
    return regex.test(x);
}
exports.isRoman = isRoman;
function toRomanLarge(x) {
    var toReturn = new RomanNumber_1.RomanNumber(0, '');
    toReturn.num = x;
    x = Math.floor(x);
    var xString = x.toString();
    // tslint:disable-next-line:radix
    toReturn.baseUnits = parseInt(xString.substring(xString.length - 3, xString.length));
    xString = xString.substring(0, xString.length - 3);
    // tslint:disable-next-line:radix
    toReturn.thousands = parseInt(xString.substring(0, xString.length));
    // future impl
    // xString = xString.substring(0, xString.length - 3);
    // // tslint:disable-next-line:radix
    // toReturn.million = parseInt(xString.substring(xString.length - 3, xString.length));
    toReturn.str = '';
    // future impl
    // if(toReturn.million !== 0){
    //   toReturn.str = toReturn.str+'__'+ toRoman(toReturn.million);
    // }
    if (toReturn.thousands !== 0) {
        toReturn.str = '(' + toReturn.str + '_' + toRoman(toReturn.thousands) + ')';
    }
    toReturn.str = toReturn.str + toRoman(toReturn.baseUnits);
    return toReturn;
}
exports.toRomanLarge = toRomanLarge;
function toRomanLargeStr(x) {
    return toRomanLarge(x).str;
}
exports.toRomanLargeStr = toRomanLargeStr;
//# sourceMappingURL=index.js.map